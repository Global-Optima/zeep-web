package types

import (
	"encoding/json"
	franchiseesTypes "github.com/Global-Optima/zeep-web/backend/internal/modules/franchisees/types"

	"github.com/Global-Optima/zeep-web/backend/internal/data"
	"github.com/Global-Optima/zeep-web/backend/internal/localization"
	storeTypes "github.com/Global-Optima/zeep-web/backend/internal/modules/stores/types"
	stockMaterialTypes "github.com/Global-Optima/zeep-web/backend/internal/modules/warehouse/stockMaterial/types"
	warehouseTypes "github.com/Global-Optima/zeep-web/backend/internal/modules/warehouse/types"
	"gorm.io/datatypes"
)

func ToStockRequestResponse(request *data.StockRequest) StockRequestResponse {
	items := make([]StockRequestMaterial, len(request.Ingredients))
	for i, ingredient := range request.Ingredients {
		items[i] = StockRequestMaterial{
			StockMaterial: *stockMaterialTypes.ConvertStockMaterialToStockMaterialResponse(&ingredient.StockMaterial),
			Quantity:      ingredient.Quantity,
		}
	}

	facilityAddress := &storeTypes.FacilityAddressDTO{
		ID:      request.Store.FacilityAddressID,
		Address: request.Store.FacilityAddress.Address,
	}

	if request.Store.FacilityAddress.Longitude == nil || request.Store.FacilityAddress.Latitude == nil {
		facilityAddress.Longitude = 0
		facilityAddress.Latitude = 0
	} else {
		facilityAddress.Longitude = *request.Store.FacilityAddress.Longitude
		facilityAddress.Latitude = *request.Store.FacilityAddress.Latitude
	}

	var franchisee *franchiseesTypes.FranchiseeDTO = nil
	if request.Store.Franchisee != nil {
		franchisee = franchiseesTypes.ConvertFranchiseeToDTO(request.Store.Franchisee)
	}

	return StockRequestResponse{
		RequestID:            request.ID,
		AutoGeneratedComment: getAutogeneratedComments(convertDetailsToStockRequestDetails(request.Details)),
		StoreComment:         request.StoreComment,
		WarehouseComment:     request.WarehouseComment,
		Store: storeTypes.StoreDTO{
			ID:              request.StoreID,
			Name:            request.Store.Name,
			Franchisee:      franchisee,
			ContactPhone:    request.Store.ContactPhone,
			ContactEmail:    request.Store.ContactEmail,
			FacilityAddress: facilityAddress,
			StoreHours:      request.Store.StoreHours,
		},
		Warehouse:      *warehouseTypes.ToWarehouseDTO(request.Warehouse),
		Status:         request.Status,
		StockMaterials: items,
		CreatedAt:      request.CreatedAt,
		UpdatedAt:      request.UpdatedAt,
	}
}

func getAutogeneratedComments(details []StockRequestDetails) *localization.LocalizedMessages {
	var mismatchComments []localization.LocalizedMessages
	var unexpectedComments []localization.LocalizedMessages

	for _, detail := range details {

		if detail.OriginalMaterialName != "" {
			newMismatchComment := GenerateMismatchCommentFromDetails(detail)
			if newMismatchComment != nil {
				mismatchComments = append(mismatchComments, *newMismatchComment)
			}
		} else {
			newUnexpectedComment := GenerateUnexpectedCommentFromDetails(detail)
			if newUnexpectedComment != nil {
				unexpectedComments = append(unexpectedComments, *newUnexpectedComment)
			}
		}
	}

	finalComments := CombineComments(mismatchComments, unexpectedComments)

	return finalComments
}

func convertDetailsToStockRequestDetails(details datatypes.JSON) []StockRequestDetails {
	var stockRequestDetails []StockRequestDetails

	if len(details) > 0 {
		if err := json.Unmarshal(details, &stockRequestDetails); err != nil {
			return []StockRequestDetails{}
		}
	}

	return stockRequestDetails
}

// if originalIngredient != nil && originalIngredient.Quantity > 0 {
// 	if err := s.repo.DeductWarehouseStock(originalIngredient.StockMaterialID, request.WarehouseID, originalIngredient.Quantity); err != nil {
// 		return fmt.Errorf("failed to deduct warehouse stock for stock material ID %d: %w", originalIngredient.StockMaterialID, err)
// 	}
// }
